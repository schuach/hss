#+TITLE: Hochschulschriften Workflow
#+AUTHOR: Stefan Schuh
#+EMAIL: stefan.schuh@uni-graz.at
#+BABEL: :session *pyhton_hss* :cache yes :exports both :tangle yes 

* Allgemeines
  Dieses Script hat die Aufgabe, die Datensäte, die von der UniIT bereitgestellt
  werden, so aufzubereiten, dass sie komfortabel in Alma eingespielt werden
  können.

  Dinge, die es können soll:
  - Unabhängig davon sein, ob die UniIT ein File pro Arbeit oder ein File pro
    Tag liefert.
  - Separate Output-Dateien erstellen für
    + elektronisch zugängliche Arbeiten
    + elektronisch nicht zugängliche Arbeiten
    + gesperrte Arbeiten
  - Duplikate entfernen, die entstehen, wenn mehrere VerfasserInnen gemeinsam
    eine Arbeit schreiben.
  - Bei gesperrten Arbeiten Abstracts und Links entfernen und bei Bedarf
    Codierungen anpassen.

*** Voraussetzungen
    Dieses Skript wird mit Python 3.6 entwickelt. Es wird angestrebt nur die
    Standardbibliothek zu verwenden, daher sollte kein Virtual Environment
    notwendig sein.

* Vorbereitendes
*** Imports
    Nachdem die Ausgangsdateien als XML geliefert werden brauchen parsen wir
    dieses mit =xml.etree.ElementTree=. Außerdem brauchen wir das Modul
    =copy=, da wir Deepcopys erstellen wollen und =os= um die Input Dateien
    aufzulisten und zu sichern.

    #+name: imports
    #+BEGIN_SRC python :session *pyhton_hss*
      import xml.etree.ElementTree as ET
      import os
    #+END_SRC

    #+RESULTS: imports
*** TODO Liste der Input files
    #+NAME: liste-input-files
    #+BEGIN_SRC python :session *pyhton_hss*
      input_dir = "input"
      infiles = []
      for filename in os.listdir(input_dir):
          infiles.append(input_dir + "/" + filename)
    #+END_SRC

    #+RESULTS: liste-input-files
    
*** Namespaces
    Damit beim schreiben der Ausgangsdateien der marc-Namespace richtig
    aufgelöst wird, müssen wir ihn gleich registrieren. Außerdem machen wir ein
    Dictionary mit dem Namespace, damit wir beim Parsen nicht immer den ganzen
    Namespace auflösen müssen (siehe [[https://stackoverflow.com/a/14853417]]):
    
    #+NAME: namespaces
    #+BEGIN_SRC python :session *pyhton_hss*
      ET.register_namespace('marc', 'http://www.loc.gov/MARC21/slim')
      ns = {'marc': 'http://www.loc.gov/MARC21/slim'}
    #+END_SRC

    #+RESULTS: namespaces

*** Templates für Output
    Nachdem die Output-Files alle das gleiche Wurzelelment haben sollen,
    verwenden wir dieses Template:
    #+NAME: xml-template
    #+BEGIN_SRC python :session *pyhton_hss*
      template = """
      <marc:collection xmlns:marc="http://www.loc.gov/MARC21/slim" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xsi:schemaLocation="http://www.loc.gov/MARC21/slim 
      http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd"/>
      """
    #+END_SRC

    #+RESULTS: xml-template

*** TODO Einzelne Elemente für Input und Output erstellen
    Es werden mehrere Elemente erstellt, die dann die Wurzeln für die Bäume
    sind, die im Endeffekt in die Output-Dateien geschrieben werden.
    - =el_zug= :: In diesen Baum kommen alle elektronisch zugänglichen Arbeiten.
    - =el_nicht= :: In diesen Baum kommen die elektronisch nicht
         zugänglichen Arbeiten.
    - =gesperrt= :: In diesen Baum kommen die gesperrten Arbeiten.
    
    #+NAME: output-trees
    #+BEGIN_SRC python :session *pyhton_hss*
    el_zug = ET.fromstring(template)
    el_nicht = ET.fromstring(template)
    gesperrt = ET.fromstring(template)
    #+END_SRC

    #+RESULTS: output-trees

    #+RESULTS:

*** TODO Die Input files in eine Liste einlesen
    Über die Infiles iterieren und alle =marc:record=-Elemente in die Liste
    =records= einlesen.
    #+NAME: read-in-input-files
    #+BEGIN_SRC python :session *pyhton_hss*
      records = []
      for file in infiles:
          tree = ET.parse(file)
          root = tree.getroot()
          for record in root.findall("./marc:record", ns):
              records.append(record)
    #+END_SRC    

    #+RESULTS: read-in-input-files

    #+RESULTS:

*** DONE Feststellen welche Datensätze zu welcher Klasse gehören
    CLOSED: [2018-01-02 Di. 15:24]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2018-01-02 Di. 15:24]
    :END:
    Eine Funktion, die feststellt, ob die Arbeit elektronisch zugänglich,
    elektronisch nicht zugänglich oder gesperrt ist.

    Nimmt ein =record=-Element als Argument und gibt den Typ als String zurück:
    
    | Typ                           | Kriterium                                                                            | Rückgabewert   |
    |-------------------------------+--------------------------------------------------------------------------------------+----------------|
    | gesperrt                      | MARC =971 7# $$Arbeit gesperrt=                                                      | 'gesp'         |
    | elektronisch nicht zugänglich | MARC =971 7# $$i AutorIn stimmte der Freigabe des elektronischen Dokuments nicht zu= | 'el_nicht_zug' |
    | elektronisch zugänglich       | Die anderen Kriterien treffen nicht zu                                               | 'el_zug'       |
    
    #+NAME: fun-check-type
    #+BEGIN_SRC python :session *pyhton_hss*
      def check_type(record):
          """Akzeptiert einen Datensatz als Argument (xml.etree.ElementTree.Element)
          und checkt, zu welchem Typ Hochschulschrift es gehärt. Gibt je nach Typ
          einen String zurück.
          """
          if record.find('./*[@tag="971"][@ind1="7"]/*[@code="i"]', ns) is not None:
              return("Elektronisch nicht zugänglich")
          elif record.find('./*[@tag="971"][@ind1="7"]/*[@code="a"]', ns) is not None:
              return("Gesperrt")
          else:
              return("elektronisch zugänglich")
    #+END_SRC

    #+RESULTS: fun-check-type

    #+RESULTS:

*** Die einzelnen Datenzätze ihrem jeweiligen Tree zuordnen
    Je nach Typ werden die einzelnen Datenzätze ihrem jeweiligen xml-Baum
    zugeordnet.
    #+BEGIN_SRC python :session *pyhton_hss*
      def alloc_to_tree(record):
          """Ordnet jeden record dem jeweiligen xml-Baum zu"""
          hss_type = check_type(record)
          if hss_type == "Elektronisch nicht zugänglich":
              el_nicht.append(record)
          elif hss_type == "Gesperrt":
              gesperrt.append(record)
          else:
              el_zug.append(record)
    #+END_SRC

    #+RESULTS:

* Alles Zusammensetzen und ein Python-Script machen
  #+BEGIN_SRC python :tangle hss.py :noweb yes
    #!/bin/python3.6
    <<imports>>  
    <<liste-input-files>>
    <<namespaces>>
    <<xml-template>>
    <<output-trees>>
    <<read-in-input-files>>
    <<fun-check-type>>
  #+END_SRC


* STARTED Tests
  :LOGBOOK:
  - State "STARTED"    from              [2018-01-02 Di. 13:59]
  :END:

  - 32 gesperrt
  - 54 elektronisch nicht zugänglich
  - 143 elektronisch zugänglich
  - 229 gesamt

  #+BEGIN_SRC python :session *pyhton_hss*
    tst_authors = []
    for record in master.findall('./marc:record', ns):
        author = record.find('.//*[@tag="100"]/*[@code="a"]').text
        tst_authors.append(author)
  #+END_SRC

  #+RESULTS:


  #+BEGIN_SRC python :session *pyhton_hss*
    for record in records:
        check_type(record)
  #+END_SRC

  #+RESULTS:
  : Elektronisch nicht zugänglich
